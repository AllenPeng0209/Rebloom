import express from 'express'\nimport cors from 'cors'\nimport helmet from 'helmet'\nimport compression from 'compression'\nimport rateLimit from 'express-rate-limit'\nimport { config, validateConfig } from '@/config'\nimport { logger, performanceLogger, errorLogger } from '@/utils/logger'\nimport { supabase, checkSupabaseHealth } from '@/services/supabaseService'\nimport { crisisDetectionService } from '@/services/crisisDetectionService'\nimport { emergencyService } from '@/services/emergencyService'\nimport { encryptionService } from '@/services/encryptionService'\nimport { auditService } from '@/services/auditService'\nimport { offlineSyncService } from '@/services/offlineSyncService'\nimport { AuthenticatedRequest } from '@/types'\n\n// Validate configuration on startup\ntry {\n  validateConfig()\n  logger.info('Configuration validated successfully')\n} catch (error) {\n  logger.error('Configuration validation failed', { error })\n  process.exit(1)\n}\n\nconst app = express()\n\n// Trust proxy for accurate IP addresses\napp.set('trust proxy', true)\n\n// Security middleware\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n      connectSrc: [\"'self'\", \"wss:\", \"https:\"],\n    },\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}))\n\n// CORS configuration\napp.use(cors({\n  origin: config.corsOrigins,\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-User-ID', 'X-Session-ID'],\n  maxAge: 86400 // 24 hours\n}))\n\n// Compression\napp.use(compression({\n  level: 6,\n  threshold: 1024, // Only compress responses > 1KB\n  filter: (req, res) => {\n    // Don't compress if the request includes 'x-no-compression' header\n    if (req.headers['x-no-compression']) {\n      return false\n    }\n    return compression.filter(req, res)\n  }\n}))\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: config.rateLimit.windowMs,\n  max: config.rateLimit.maxRequests,\n  message: {\n    error: 'Too many requests from this IP, please try again later.',\n    retryAfter: Math.ceil(config.rateLimit.windowMs / 1000)\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  handler: (req, res) => {\n    logger.warn('Rate limit exceeded', {\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      path: req.path\n    })\n    res.status(429).json({\n      success: false,\n      error: 'Too many requests',\n      retryAfter: Math.ceil(config.rateLimit.windowMs / 1000)\n    })\n  }\n})\n\napp.use('/api/', limiter)\n\n// Body parsing middleware\napp.use(express.json({ \n  limit: '10mb',\n  verify: (req, res, buf) => {\n    // Store raw body for webhook signature verification\n    ;(req as any).rawBody = buf\n  }\n}))\napp.use(express.urlencoded({ extended: true, limit: '10mb' }))\n\n// Request logging and performance monitoring\napp.use((req, res, next) => {\n  const startTime = Date.now()\n  \n  // Log request\n  logger.info('Incoming request', {\n    method: req.method,\n    path: req.path,\n    ip: req.ip,\n    userAgent: req.get('User-Agent'),\n    userId: req.headers['x-user-id']\n  })\n  \n  // Performance monitoring\n  res.on('finish', () => {\n    const duration = Date.now() - startTime\n    performanceLogger.logApiRequest(\n      req.method,\n      req.path,\n      duration,\n      res.statusCode,\n      req.headers['x-user-id'] as string\n    )\n  })\n  \n  next()\n})\n\n// Health check endpoint\napp.get('/health', async (req, res) => {\n  try {\n    const supabaseHealth = await checkSupabaseHealth()\n    \n    const health = {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      version: '1.0.0',\n      environment: config.env,\n      services: {\n        supabase: supabaseHealth,\n        encryption: { healthy: true, message: 'Encryption service operational' },\n        ai: { healthy: !!config.ai.bailianApiKey, message: config.ai.bailianApiKey ? 'AI service configured' : 'AI service not configured' }\n      },\n      uptime: process.uptime(),\n      memory: process.memoryUsage(),\n      cpu: process.cpuUsage()\n    }\n    \n    const isHealthy = supabaseHealth.healthy\n    res.status(isHealthy ? 200 : 503).json(health)\n  } catch (error) {\n    logger.error('Health check failed', { error })\n    res.status(503).json({\n      status: 'unhealthy',\n      timestamp: new Date().toISOString(),\n      error: error instanceof Error ? error.message : 'Unknown error'\n    })\n  }\n})\n\n// Ready check endpoint (for Kubernetes)\napp.get('/ready', async (req, res) => {\n  try {\n    // Check if all required services are ready\n    const supabaseHealth = await checkSupabaseHealth()\n    \n    if (!supabaseHealth.healthy) {\n      throw new Error('Supabase not ready')\n    }\n    \n    res.status(200).json({\n      status: 'ready',\n      timestamp: new Date().toISOString()\n    })\n  } catch (error) {\n    res.status(503).json({\n      status: 'not ready',\n      timestamp: new Date().toISOString(),\n      error: error instanceof Error ? error.message : 'Unknown error'\n    })\n  }\n})\n\n// Crisis Detection API\napp.post('/api/v1/crisis/analyze', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { message, userId, sessionId, messageId } = req.body\n    \n    if (!message || !userId) {\n      return res.status(400).json({\n        success: false,\n        error: 'Message and userId are required'\n      })\n    }\n    \n    const assessment = await crisisDetectionService.analyzeMessage(\n      message,\n      userId,\n      sessionId || 'anonymous',\n      messageId || 'temp'\n    )\n    \n    res.json({\n      success: true,\n      data: assessment,\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/crisis/analyze' })\n    res.status(500).json({\n      success: false,\n      error: 'Crisis analysis failed'\n    })\n  }\n})\n\n// Emergency Services API\napp.post('/api/v1/emergency/contact', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId, emergencyType = 'mental_health_crisis' } = req.body\n    \n    if (!userId) {\n      return res.status(400).json({\n        success: false,\n        error: 'UserId is required'\n      })\n    }\n    \n    const result = await emergencyService.contactEmergencyServices(userId, emergencyType)\n    \n    res.json({\n      success: result.success,\n      data: result,\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/emergency/contact' })\n    res.status(500).json({\n      success: false,\n      error: 'Emergency contact failed'\n    })\n  }\n})\n\n// Crisis Hotline Connection\napp.post('/api/v1/crisis/hotline', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId, location, preferredLanguage = 'en' } = req.body\n    \n    if (!userId) {\n      return res.status(400).json({\n        success: false,\n        error: 'UserId is required'\n      })\n    }\n    \n    const result = await emergencyService.connectToCrisisHotline(\n      userId,\n      location,\n      preferredLanguage\n    )\n    \n    res.json({\n      success: result.success,\n      data: result,\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/crisis/hotline' })\n    res.status(500).json({\n      success: false,\n      error: 'Crisis hotline connection failed'\n    })\n  }\n})\n\n// Safety Plan Creation\napp.post('/api/v1/safety/plan', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId, assessment, existingPlan } = req.body\n    \n    if (!userId || !assessment) {\n      return res.status(400).json({\n        success: false,\n        error: 'UserId and assessment are required'\n      })\n    }\n    \n    const safetyPlan = await emergencyService.createSafetyPlan(\n      userId,\n      assessment,\n      existingPlan\n    )\n    \n    res.json({\n      success: true,\n      data: safetyPlan,\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/safety/plan' })\n    res.status(500).json({\n      success: false,\n      error: 'Safety plan creation failed'\n    })\n  }\n})\n\n// Offline Sync API\napp.post('/api/v1/sync/queue', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId, operation, table, localId, data, priority = 5 } = req.body\n    \n    if (!userId || !operation || !table || !localId || !data) {\n      return res.status(400).json({\n        success: false,\n        error: 'Required fields: userId, operation, table, localId, data'\n      })\n    }\n    \n    const operationId = await offlineSyncService.queueOperation(\n      userId,\n      operation,\n      table,\n      localId,\n      data,\n      priority\n    )\n    \n    res.json({\n      success: true,\n      data: { operationId },\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/sync/queue' })\n    res.status(500).json({\n      success: false,\n      error: 'Failed to queue sync operation'\n    })\n  }\n})\n\n// Sync Status Check\napp.get('/api/v1/sync/status/:userId', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId } = req.params\n    \n    const status = await offlineSyncService.getUserSyncStatus(userId)\n    \n    res.json({\n      success: true,\n      data: status,\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/sync/status' })\n    res.status(500).json({\n      success: false,\n      error: 'Failed to get sync status'\n    })\n  }\n})\n\n// Force Sync\napp.post('/api/v1/sync/force', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId, highPriorityOnly = false } = req.body\n    \n    if (!userId) {\n      return res.status(400).json({\n        success: false,\n        error: 'UserId is required'\n      })\n    }\n    \n    const result = highPriorityOnly \n      ? await offlineSyncService.forceSyncHighPriority(userId)\n      : await offlineSyncService.syncUser(userId, true)\n    \n    res.json({\n      success: result.success,\n      data: result,\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/sync/force' })\n    res.status(500).json({\n      success: false,\n      error: 'Sync failed'\n    })\n  }\n})\n\n// Encryption Services\napp.post('/api/v1/encrypt/phi', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { data, userId, userKey, dataType } = req.body\n    \n    if (!data || !userId || !userKey || !dataType) {\n      return res.status(400).json({\n        success: false,\n        error: 'Required fields: data, userId, userKey, dataType'\n      })\n    }\n    \n    const encrypted = await encryptionService.encryptPHI(\n      data,\n      userId,\n      userKey,\n      dataType\n    )\n    \n    res.json({\n      success: true,\n      data: encrypted,\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/encrypt/phi' })\n    res.status(500).json({\n      success: false,\n      error: 'Encryption failed'\n    })\n  }\n})\n\n// Compliance and Audit\napp.get('/api/v1/audit/logs', async (req: AuthenticatedRequest, res) => {\n  try {\n    const {\n      userId,\n      eventType,\n      startDate,\n      endDate,\n      riskLevel,\n      phiAccessed,\n      limit = 50,\n      offset = 0\n    } = req.query\n    \n    const filters = {\n      userId: userId as string,\n      eventType: eventType as string,\n      startDate: startDate ? new Date(startDate as string) : undefined,\n      endDate: endDate ? new Date(endDate as string) : undefined,\n      riskLevel: riskLevel as string,\n      phiAccessed: phiAccessed === 'true',\n      limit: parseInt(limit as string),\n      offset: parseInt(offset as string)\n    }\n    \n    const result = await auditService.searchAuditLogs(filters)\n    \n    res.json({\n      success: true,\n      data: result.logs,\n      pagination: {\n        total: result.total,\n        limit: filters.limit,\n        offset: filters.offset,\n        hasMore: result.total > (filters.offset + filters.limit)\n      },\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/audit/logs' })\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve audit logs'\n    })\n  }\n})\n\n// Compliance Report Generation\napp.post('/api/v1/compliance/report', async (req: AuthenticatedRequest, res) => {\n  try {\n    const { startDate, endDate, reportType = 'full' } = req.body\n    \n    if (!startDate || !endDate) {\n      return res.status(400).json({\n        success: false,\n        error: 'Start date and end date are required'\n      })\n    }\n    \n    const report = await auditService.generateComplianceReport(\n      new Date(startDate),\n      new Date(endDate),\n      reportType\n    )\n    \n    res.json({\n      success: true,\n      data: report,\n      timestamp: new Date()\n    })\n  } catch (error) {\n    errorLogger.logError(error as Error, { endpoint: '/api/v1/compliance/report' })\n    res.status(500).json({\n      success: false,\n      error: 'Failed to generate compliance report'\n    })\n  }\n})\n\n// Global error handler\napp.use((error: Error, req: AuthenticatedRequest, res: any, next: any) => {\n  errorLogger.logError(error, {\n    method: req.method,\n    path: req.path,\n    userId: req.headers['x-user-id'],\n    ip: req.ip\n  })\n  \n  // Don't leak error details in production\n  const isDevelopment = config.env === 'development'\n  \n  res.status(500).json({\n    success: false,\n    error: 'Internal server error',\n    ...(isDevelopment && {\n      details: error.message,\n      stack: error.stack\n    }),\n    timestamp: new Date(),\n    requestId: req.headers['x-request-id']\n  })\n})\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    success: false,\n    error: 'Endpoint not found',\n    path: req.path,\n    method: req.method,\n    timestamp: new Date()\n  })\n})\n\n// Graceful shutdown\nprocess.on('SIGTERM', async () => {\n  logger.info('Received SIGTERM, shutting down gracefully')\n  \n  // Cleanup resources\n  offlineSyncService.cleanup()\n  \n  server.close(() => {\n    logger.info('Server closed')\n    process.exit(0)\n  })\n  \n  // Force exit after 30 seconds\n  setTimeout(() => {\n    logger.error('Forced shutdown after timeout')\n    process.exit(1)\n  }, 30000)\n})\n\nprocess.on('SIGINT', async () => {\n  logger.info('Received SIGINT, shutting down gracefully')\n  \n  offlineSyncService.cleanup()\n  \n  server.close(() => {\n    logger.info('Server closed')\n    process.exit(0)\n  })\n})\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  errorLogger.logCriticalError(new Error(`Unhandled Rejection: ${reason}`), { promise })\n})\n\nprocess.on('uncaughtException', (error) => {\n  errorLogger.logCriticalError(error, { type: 'uncaughtException' })\n  process.exit(1)\n})\n\n// Start server\nconst server = app.listen(config.port, () => {\n  logger.info(`Rebloom Backend Server started`, {\n    port: config.port,\n    environment: config.env,\n    nodeVersion: process.version,\n    pid: process.pid\n  })\n  \n  // Initialize services\n  logger.info('Initializing backend services...')\n  \n  // Health check on startup\n  checkSupabaseHealth().then((health) => {\n    if (health.healthy) {\n      logger.info('All services initialized successfully')\n    } else {\n      logger.error('Service health check failed', health)\n    }\n  })\n})\n\nexport default app