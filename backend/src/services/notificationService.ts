import { CrisisAssessment } from '@/types'\nimport { logger, businessLogger } from '@/utils/logger'\nimport { supabase } from './supabaseService'\nimport { auditService } from './auditService'\n\ninterface NotificationTemplate {\n  id: string\n  type: 'crisis_resources' | 'safety_plan' | 'emotional_support' | 'coping_strategies'\n  urgency: 'low' | 'medium' | 'high' | 'critical'\n  channels: ('push' | 'sms' | 'email' | 'in_app')[]\n  template: {\n    title: string\n    body: string\n    actions?: { label: string, action: string }[]\n  }\n}\n\ninterface NotificationResult {\n  success: boolean\n  channel: string\n  messageId?: string\n  error?: string\n  deliveredAt?: Date\n}\n\nclass NotificationService {\n  private readonly templates: Record<string, NotificationTemplate> = {\n    crisis_resources_critical: {\n      id: 'crisis_resources_critical',\n      type: 'crisis_resources',\n      urgency: 'critical',\n      channels: ['push', 'sms'],\n      template: {\n        title: 'Crisis Support Available',\n        body: 'You are not alone. Immediate help is available. Tap for crisis resources and support.',\n        actions: [\n          { label: 'Crisis Hotline', action: 'call_crisis_hotline' },\n          { label: 'Safety Plan', action: 'open_safety_plan' },\n          { label: 'Emergency Services', action: 'contact_emergency' }\n        ]\n      }\n    },\n    emotional_support: {\n      id: 'emotional_support',\n      type: 'emotional_support',\n      urgency: 'medium',\n      channels: ['push', 'in_app'],\n      template: {\n        title: 'You Are Valued',\n        body: 'Remember that your feelings are valid and you matter. Take a moment for yourself.',\n        actions: [\n          { label: 'Breathing Exercise', action: 'start_breathing' },\n          { label: 'Talk to Someone', action: 'open_chat' }\n        ]\n      }\n    },\n    safety_plan: {\n      id: 'safety_plan',\n      type: 'safety_plan',\n      urgency: 'high',\n      channels: ['push', 'in_app'],\n      template: {\n        title: 'Your Safety Plan',\n        body: 'Your personalized safety plan is ready. It includes coping strategies and emergency contacts.',\n        actions: [\n          { label: 'View Plan', action: 'open_safety_plan' },\n          { label: 'Practice Coping', action: 'start_coping' }\n        ]\n      }\n    },\n    coping_strategies: {\n      id: 'coping_strategies',\n      type: 'coping_strategies',\n      urgency: 'medium',\n      channels: ['push', 'in_app'],\n      template: {\n        title: 'Coping Strategies',\n        body: 'Here are some techniques that might help you feel better right now.',\n        actions: [\n          { label: 'Try Breathing', action: 'start_breathing' },\n          { label: 'Grounding Exercise', action: 'start_grounding' }\n        ]\n      }\n    }\n  }\n\n  /**\n   * Send crisis resources to user\n   */\n  async sendCrisisResources(\n    userId: string,\n    crisisData: {\n      riskLevel: string\n      triggers: string[]\n      resources: any[]\n      location?: any\n      timestamp: Date\n    }\n  ): Promise<NotificationResult[]> {\n    try {\n      const templateId = crisisData.riskLevel === 'critical' \n        ? 'crisis_resources_critical' \n        : 'crisis_resources_critical' // Use critical for any crisis\n      \n      const template = this.templates[templateId]\n      \n      // Get user notification preferences\n      const userPreferences = await this.getUserNotificationPreferences(userId)\n      \n      // Determine channels based on urgency and preferences\n      const channels = this.selectChannels(template, userPreferences)\n      \n      // Send notifications across selected channels\n      const results = await Promise.allSettled(\n        channels.map(channel => this.sendNotification(\n          userId,\n          channel,\n          {\n            ...template.template,\n            body: this.personalizeCrisisMessage(template.template.body, crisisData)\n          },\n          {\n            type: 'crisis_resources',\n            urgency: template.urgency,\n            data: {\n              riskLevel: crisisData.riskLevel,\n              resources: crisisData.resources,\n              timestamp: crisisData.timestamp\n            }\n          }\n        ))\n      )\n      \n      const notificationResults = results.map((result, index) => ({\n        success: result.status === 'fulfilled',\n        channel: channels[index],\n        messageId: result.status === 'fulfilled' ? result.value.messageId : undefined,\n        error: result.status === 'rejected' ? result.reason : undefined,\n        deliveredAt: result.status === 'fulfilled' ? new Date() : undefined\n      }))\n      \n      // Log crisis resource delivery\n      businessLogger.logIntervention(\n        userId,\n        'crisis_resources_sent',\n        `Channels: ${channels.join(', ')}, Success: ${notificationResults.filter(r => r.success).length}/${notificationResults.length}`,\n        notificationResults.some(r => r.success)\n      )\n      \n      // Store notification record\n      await this.storeNotificationRecord(userId, 'crisis_resources', notificationResults)\n      \n      return notificationResults\n      \n    } catch (error) {\n      logger.error('Crisis resource notification failed', { userId, error })\n      return [{\n        success: false,\n        channel: 'unknown',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      }]\n    }\n  }\n\n  /**\n   * Send safety plan to user\n   */\n  async sendSafetyPlan(userId: string, safetyPlan: any): Promise<NotificationResult[]> {\n    try {\n      const template = this.templates.safety_plan\n      const userPreferences = await this.getUserNotificationPreferences(userId)\n      const channels = this.selectChannels(template, userPreferences)\n      \n      const results = await Promise.allSettled(\n        channels.map(channel => this.sendNotification(\n          userId,\n          channel,\n          template.template,\n          {\n            type: 'safety_plan',\n            urgency: template.urgency,\n            data: {\n              safetyPlanId: safetyPlan.id,\n              createdAt: safetyPlan.createdAt\n            }\n          }\n        ))\n      )\n      \n      const notificationResults = results.map((result, index) => ({\n        success: result.status === 'fulfilled',\n        channel: channels[index],\n        messageId: result.status === 'fulfilled' ? result.value.messageId : undefined,\n        error: result.status === 'rejected' ? result.reason : undefined,\n        deliveredAt: result.status === 'fulfilled' ? new Date() : undefined\n      }))\n      \n      businessLogger.logIntervention(\n        userId,\n        'safety_plan_sent',\n        `Channels: ${channels.join(', ')}`,\n        notificationResults.some(r => r.success)\n      )\n      \n      await this.storeNotificationRecord(userId, 'safety_plan', notificationResults)\n      \n      return notificationResults\n      \n    } catch (error) {\n      logger.error('Safety plan notification failed', { userId, error })\n      return [{ success: false, channel: 'unknown', error: error instanceof Error ? error.message : 'Unknown error' }]\n    }\n  }\n\n  /**\n   * Send emotional support message\n   */\n  async sendEmotionalSupport(userId: string): Promise<NotificationResult[]> {\n    try {\n      const template = this.templates.emotional_support\n      const userPreferences = await this.getUserNotificationPreferences(userId)\n      const channels = this.selectChannels(template, userPreferences)\n      \n      const results = await Promise.allSettled(\n        channels.map(channel => this.sendNotification(\n          userId,\n          channel,\n          template.template,\n          {\n            type: 'emotional_support',\n            urgency: template.urgency,\n            data: { sentAt: new Date() }\n          }\n        ))\n      )\n      \n      const notificationResults = results.map((result, index) => ({\n        success: result.status === 'fulfilled',\n        channel: channels[index],\n        messageId: result.status === 'fulfilled' ? result.value.messageId : undefined,\n        error: result.status === 'rejected' ? result.reason : undefined,\n        deliveredAt: result.status === 'fulfilled' ? new Date() : undefined\n      }))\n      \n      await this.storeNotificationRecord(userId, 'emotional_support', notificationResults)\n      \n      return notificationResults\n      \n    } catch (error) {\n      logger.error('Emotional support notification failed', { userId, error })\n      return [{ success: false, channel: 'unknown', error: error instanceof Error ? error.message : 'Unknown error' }]\n    }\n  }\n\n  /**\n   * Send coping strategies\n   */\n  async sendCopingStrategies(userId: string, strategies: string[]): Promise<NotificationResult[]> {\n    try {\n      const template = this.templates.coping_strategies\n      const userPreferences = await this.getUserNotificationPreferences(userId)\n      const channels = this.selectChannels(template, userPreferences)\n      \n      // Customize message with specific strategies\n      const customizedTemplate = {\n        ...template.template,\n        body: `${template.template.body}\\n\\nSuggestions:\\n${strategies.slice(0, 3).map(s => `â€¢ ${s}`).join('\\n')}`\n      }\n      \n      const results = await Promise.allSettled(\n        channels.map(channel => this.sendNotification(\n          userId,\n          channel,\n          customizedTemplate,\n          {\n            type: 'coping_strategies',\n            urgency: template.urgency,\n            data: { strategies, sentAt: new Date() }\n          }\n        ))\n      )\n      \n      const notificationResults = results.map((result, index) => ({\n        success: result.status === 'fulfilled',\n        channel: channels[index],\n        messageId: result.status === 'fulfilled' ? result.value.messageId : undefined,\n        error: result.status === 'rejected' ? result.reason : undefined,\n        deliveredAt: result.status === 'fulfilled' ? new Date() : undefined\n      }))\n      \n      await this.storeNotificationRecord(userId, 'coping_strategies', notificationResults)\n      \n      return notificationResults\n      \n    } catch (error) {\n      logger.error('Coping strategies notification failed', { userId, error })\n      return [{ success: false, channel: 'unknown', error: error instanceof Error ? error.message : 'Unknown error' }]\n    }\n  }\n\n  /**\n   * Alert professionals about crisis\n   */\n  async alertProfessionals(assessment: CrisisAssessment): Promise<void> {\n    try {\n      // Get assigned professionals for the user\n      const professionals = await this.getAssignedProfessionals(assessment.userId)\n      \n      if (professionals.length === 0) {\n        logger.warn('No professionals assigned for crisis alert', { userId: assessment.userId })\n        return\n      }\n      \n      // Send alerts to professionals\n      const alertPromises = professionals.map(professional => \n        this.sendProfessionalAlert(professional, assessment)\n      )\n      \n      const results = await Promise.allSettled(alertPromises)\n      const successCount = results.filter(r => r.status === 'fulfilled').length\n      \n      businessLogger.logIntervention(\n        assessment.userId,\n        'professional_alert',\n        `Alerted ${successCount}/${professionals.length} professionals`,\n        successCount > 0\n      )\n      \n      // Log professional notification in audit trail\n      await auditService.logProfessionalAccess(\n        'system',\n        assessment.userId,\n        'emergency',\n        `Crisis alert sent - Risk: ${assessment.riskLevel}`,\n        { ipAddress: undefined, sessionId: undefined }\n      )\n      \n    } catch (error) {\n      logger.error('Professional alert failed', { assessmentId: assessment.id, error })\n    }\n  }\n\n  /**\n   * Send scheduled reminders and check-ins\n   */\n  async sendScheduledCheckIn(\n    userId: string,\n    checkInType: 'daily' | 'weekly' | 'follow_up' | 'safety_check',\n    customMessage?: string\n  ): Promise<NotificationResult[]> {\n    try {\n      const templates = {\n        daily: {\n          title: 'Daily Check-In',\n          body: customMessage || 'How are you feeling today? Take a moment to check in with yourself.',\n          actions: [\n            { label: 'Log Mood', action: 'open_mood_tracker' },\n            { label: 'Chat', action: 'open_chat' }\n          ]\n        },\n        weekly: {\n          title: 'Weekly Reflection',\n          body: customMessage || 'How has your week been? Reflecting on your progress can be helpful.',\n          actions: [\n            { label: 'Weekly Review', action: 'open_weekly_review' },\n            { label: 'Set Goals', action: 'open_goals' }\n          ]\n        },\n        follow_up: {\n          title: 'Following Up',\n          body: customMessage || 'Checking in after our recent conversation. How are you doing?',\n          actions: [\n            { label: 'Update Status', action: 'open_status_update' },\n            { label: 'Need Support', action: 'request_support' }\n          ]\n        },\n        safety_check: {\n          title: 'Safety Check',\n          body: customMessage || 'Just wanted to check - are you in a safe place and feeling okay?',\n          actions: [\n            { label: \"I'm Okay\", action: 'confirm_safety' },\n            { label: 'Need Help', action: 'request_help' }\n          ]\n        }\n      }\n      \n      const template = templates[checkInType]\n      const userPreferences = await this.getUserNotificationPreferences(userId)\n      \n      // Use gentle channels for check-ins\n      const channels = userPreferences.checkIns?.channels || ['push']\n      \n      const results = await Promise.allSettled(\n        channels.map(channel => this.sendNotification(\n          userId,\n          channel,\n          template,\n          {\n            type: 'check_in',\n            urgency: 'low',\n            data: { checkInType, sentAt: new Date() }\n          }\n        ))\n      )\n      \n      const notificationResults = results.map((result, index) => ({\n        success: result.status === 'fulfilled',\n        channel: channels[index],\n        messageId: result.status === 'fulfilled' ? result.value.messageId : undefined,\n        error: result.status === 'rejected' ? result.reason : undefined,\n        deliveredAt: result.status === 'fulfilled' ? new Date() : undefined\n      }))\n      \n      await this.storeNotificationRecord(userId, 'check_in', notificationResults)\n      \n      return notificationResults\n      \n    } catch (error) {\n      logger.error('Scheduled check-in failed', { userId, checkInType, error })\n      return [{ success: false, channel: 'unknown', error: error instanceof Error ? error.message : 'Unknown error' }]\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async getUserNotificationPreferences(userId: string): Promise<any> {\n    try {\n      const { data: preferences } = await supabase\n        .from('user_notification_preferences')\n        .select('*')\n        .eq('user_id', userId)\n        .single()\n      \n      return preferences || {\n        push: true,\n        sms: false,\n        email: false,\n        in_app: true,\n        crisis: { channels: ['push', 'sms'] },\n        checkIns: { channels: ['push'], frequency: 'daily' }\n      }\n    } catch (error) {\n      // Return default preferences\n      return {\n        push: true,\n        sms: false,\n        email: false,\n        in_app: true,\n        crisis: { channels: ['push'] },\n        checkIns: { channels: ['push'], frequency: 'daily' }\n      }\n    }\n  }\n\n  private selectChannels(\n    template: NotificationTemplate,\n    userPreferences: any\n  ): ('push' | 'sms' | 'email' | 'in_app')[] {\n    const availableChannels = template.channels\n    \n    // For critical urgency, override user preferences\n    if (template.urgency === 'critical') {\n      return availableChannels\n    }\n    \n    // Filter by user preferences\n    return availableChannels.filter(channel => {\n      if (template.type === 'crisis_resources') {\n        return userPreferences.crisis?.channels?.includes(channel) ?? availableChannels.includes(channel)\n      }\n      return userPreferences[channel] === true\n    })\n  }\n\n  private async sendNotification(\n    userId: string,\n    channel: string,\n    template: { title: string, body: string, actions?: any[] },\n    metadata: any\n  ): Promise<{ messageId: string }> {\n    try {\n      switch (channel) {\n        case 'push':\n          return await this.sendPushNotification(userId, template, metadata)\n        case 'sms':\n          return await this.sendSMSNotification(userId, template, metadata)\n        case 'email':\n          return await this.sendEmailNotification(userId, template, metadata)\n        case 'in_app':\n          return await this.sendInAppNotification(userId, template, metadata)\n        default:\n          throw new Error(`Unsupported notification channel: ${channel}`)\n      }\n    } catch (error) {\n      logger.error(`${channel} notification failed`, { userId, error })\n      throw error\n    }\n  }\n\n  private async sendPushNotification(\n    userId: string,\n    template: any,\n    metadata: any\n  ): Promise<{ messageId: string }> {\n    // TODO: Integrate with push notification service (FCM, APNs)\n    // For now, return mock success\n    return { messageId: `push_${Date.now()}` }\n  }\n\n  private async sendSMSNotification(\n    userId: string,\n    template: any,\n    metadata: any\n  ): Promise<{ messageId: string }> {\n    // TODO: Integrate with SMS service (Twilio, AWS SNS)\n    // For now, return mock success\n    return { messageId: `sms_${Date.now()}` }\n  }\n\n  private async sendEmailNotification(\n    userId: string,\n    template: any,\n    metadata: any\n  ): Promise<{ messageId: string }> {\n    // TODO: Integrate with email service (SendGrid, AWS SES)\n    // For now, return mock success\n    return { messageId: `email_${Date.now()}` }\n  }\n\n  private async sendInAppNotification(\n    userId: string,\n    template: any,\n    metadata: any\n  ): Promise<{ messageId: string }> {\n    // Store in-app notification in database\n    const notificationId = `in_app_${Date.now()}`\n    \n    await supabase\n      .from('in_app_notifications')\n      .insert({\n        id: notificationId,\n        user_id: userId,\n        title: template.title,\n        body: template.body,\n        actions: template.actions || [],\n        metadata,\n        read: false,\n        created_at: new Date()\n      })\n    \n    return { messageId: notificationId }\n  }\n\n  private personalizeCrisisMessage(baseMessage: string, crisisData: any): string {\n    // Add personalization based on risk level and triggers\n    if (crisisData.riskLevel === 'critical') {\n      return `${baseMessage} This is urgent - please reach out for help immediately.`\n    } else if (crisisData.riskLevel === 'high') {\n      return `${baseMessage} Your safety matters - support is available.`\n    }\n    return baseMessage\n  }\n\n  private async getAssignedProfessionals(userId: string): Promise<any[]> {\n    try {\n      const { data: professionals } = await supabase\n        .from('user_professional_relationships')\n        .select(`\n          professional_id,\n          professionals (\n            id,\n            name,\n            email,\n            phone,\n            specialization,\n            notification_preferences\n          )\n        `)\n        .eq('user_id', userId)\n        .eq('status', 'active')\n      \n      return professionals?.map(p => p.professionals) || []\n    } catch (error) {\n      logger.error('Failed to get assigned professionals', { userId, error })\n      return []\n    }\n  }\n\n  private async sendProfessionalAlert(\n    professional: any,\n    assessment: CrisisAssessment\n  ): Promise<void> {\n    const alertMessage = {\n      title: `Crisis Alert - Patient ${assessment.userId}`,\n      body: `High-risk situation detected. Risk level: ${assessment.riskLevel}. Confidence: ${Math.round(assessment.confidence * 100)}%. Immediate attention recommended.`,\n      data: {\n        userId: assessment.userId,\n        assessmentId: assessment.id,\n        riskLevel: assessment.riskLevel,\n        triggers: assessment.triggers,\n        timestamp: assessment.timestamp\n      }\n    }\n    \n    // Send via professional's preferred channels\n    const channels = professional.notification_preferences?.crisis_alerts || ['email']\n    \n    await Promise.allSettled(\n      channels.map(channel => {\n        // TODO: Implement professional notification channels\n        logger.info('Professional alert sent', {\n          professionalId: professional.id,\n          channel,\n          assessmentId: assessment.id\n        })\n      })\n    )\n  }\n\n  private async storeNotificationRecord(\n    userId: string,\n    type: string,\n    results: NotificationResult[]\n  ): Promise<void> {\n    try {\n      await supabase\n        .from('notification_history')\n        .insert({\n          user_id: userId,\n          notification_type: type,\n          channels_attempted: results.map(r => r.channel),\n          successful_channels: results.filter(r => r.success).map(r => r.channel),\n          results: JSON.stringify(results),\n          sent_at: new Date()\n        })\n    } catch (error) {\n      logger.error('Failed to store notification record', { userId, type, error })\n    }\n  }\n}\n\nexport const notificationService = new NotificationService()\nexport default notificationService