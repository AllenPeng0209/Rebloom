import { v4 as uuidv4 } from 'uuid'\nimport { Message, ConversationSession, MoodEntry } from '@/types'\nimport { logger, performanceLogger } from '@/utils/logger'\nimport { supabase } from './supabaseService'\nimport { encryptionService } from './encryptionService'\n\ninterface SyncOperation {\n  id: string\n  userId: string\n  operation: 'create' | 'update' | 'delete'\n  table: string\n  localId: string\n  serverId?: string\n  data: any\n  timestamp: Date\n  retries: number\n  status: 'pending' | 'syncing' | 'completed' | 'failed' | 'conflict'\n  conflictData?: any\n  priority: number // 1 = highest, 10 = lowest\n}\n\ninterface ConflictResolution {\n  strategy: 'client_wins' | 'server_wins' | 'merge' | 'manual_review'\n  resolvedData: any\n  metadata: {\n    conflictType: string\n    clientVersion: number\n    serverVersion: number\n    resolvedAt: Date\n  }\n}\n\ninterface SyncResult {\n  success: boolean\n  operations: {\n    total: number\n    successful: number\n    failed: number\n    conflicts: number\n  }\n  conflicts: ConflictResolution[]\n  errors: string[]\n  performance: {\n    duration: number\n    throughput: number // ops per second\n  }\n}\n\ninterface SyncQueue {\n  userId: string\n  operations: SyncOperation[]\n  lastSyncAt?: Date\n  syncInProgress: boolean\n}\n\nclass OfflineSyncService {\n  private syncQueues: Map<string, SyncQueue> = new Map()\n  private readonly maxRetries = 3\n  private readonly batchSize = 50\n  private readonly syncIntervalMs = 30000 // 30 seconds\n  private syncIntervals: Map<string, NodeJS.Timeout> = new Map()\n\n  /**\n   * Initialize offline sync for a user\n   */\n  async initializeUserSync(userId: string): Promise<void> {\n    try {\n      if (!this.syncQueues.has(userId)) {\n        this.syncQueues.set(userId, {\n          userId,\n          operations: [],\n          syncInProgress: false\n        })\n      }\n\n      // Load pending operations from database\n      await this.loadPendingOperations(userId)\n\n      // Start periodic sync\n      this.startPeriodicSync(userId)\n\n      logger.info('User sync initialized', { userId })\n    } catch (error) {\n      logger.error('Failed to initialize user sync', { userId, error })\n      throw error\n    }\n  }\n\n  /**\n   * Queue an operation for sync\n   */\n  async queueOperation(\n    userId: string,\n    operation: 'create' | 'update' | 'delete',\n    table: string,\n    localId: string,\n    data: any,\n    priority: number = 5\n  ): Promise<string> {\n    try {\n      const operationId = uuidv4()\n      const syncOperation: SyncOperation = {\n        id: operationId,\n        userId,\n        operation,\n        table,\n        localId,\n        data,\n        timestamp: new Date(),\n        retries: 0,\n        status: 'pending',\n        priority\n      }\n\n      // Add to queue\n      const queue = this.syncQueues.get(userId)\n      if (queue) {\n        queue.operations.push(syncOperation)\n        // Sort by priority and timestamp\n        queue.operations.sort((a, b) => {\n          if (a.priority !== b.priority) return a.priority - b.priority\n          return a.timestamp.getTime() - b.timestamp.getTime()\n        })\n      }\n\n      // Persist operation to local storage\n      await this.persistSyncOperation(syncOperation)\n\n      // Trigger immediate sync for high priority operations\n      if (priority <= 2) {\n        setImmediate(() => this.syncUser(userId))\n      }\n\n      return operationId\n    } catch (error) {\n      logger.error('Failed to queue sync operation', { userId, operation, table, error })\n      throw error\n    }\n  }\n\n  /**\n   * Sync all pending operations for a user\n   */\n  async syncUser(userId: string, forceSync: boolean = false): Promise<SyncResult> {\n    const startTime = Date.now()\n    const queue = this.syncQueues.get(userId)\n    \n    if (!queue) {\n      throw new Error(`No sync queue found for user ${userId}`)\n    }\n\n    if (queue.syncInProgress && !forceSync) {\n      logger.debug('Sync already in progress', { userId })\n      return {\n        success: false,\n        operations: { total: 0, successful: 0, failed: 0, conflicts: 0 },\n        conflicts: [],\n        errors: ['Sync already in progress'],\n        performance: { duration: 0, throughput: 0 }\n      }\n    }\n\n    queue.syncInProgress = true\n    const operations = [...queue.operations.filter(op => op.status === 'pending' || op.status === 'failed')]\n    \n    if (operations.length === 0) {\n      queue.syncInProgress = false\n      return {\n        success: true,\n        operations: { total: 0, successful: 0, failed: 0, conflicts: 0 },\n        conflicts: [],\n        errors: [],\n        performance: { duration: Date.now() - startTime, throughput: 0 }\n      }\n    }\n\n    logger.info('Starting sync', { userId, operationCount: operations.length })\n\n    const results = {\n      total: operations.length,\n      successful: 0,\n      failed: 0,\n      conflicts: 0\n    }\n    const conflicts: ConflictResolution[] = []\n    const errors: string[] = []\n\n    try {\n      // Process operations in batches\n      for (let i = 0; i < operations.length; i += this.batchSize) {\n        const batch = operations.slice(i, i + this.batchSize)\n        const batchResults = await this.processBatch(batch)\n        \n        results.successful += batchResults.successful\n        results.failed += batchResults.failed\n        results.conflicts += batchResults.conflicts\n        conflicts.push(...batchResults.conflictResolutions)\n        errors.push(...batchResults.errors)\n      }\n\n      // Update queue - remove completed operations\n      queue.operations = queue.operations.filter(\n        op => !operations.some(syncOp => syncOp.id === op.id && op.status === 'completed')\n      )\n      \n      queue.lastSyncAt = new Date()\n      \n      const duration = Date.now() - startTime\n      const throughput = operations.length / (duration / 1000)\n      \n      performanceLogger.logExternalServiceCall(\n        'offline_sync',\n        `sync_${userId}`,\n        duration,\n        results.failed === 0\n      )\n\n      logger.info('Sync completed', {\n        userId,\n        duration,\n        throughput: throughput.toFixed(2),\n        ...results\n      })\n\n      return {\n        success: results.failed === 0,\n        operations: results,\n        conflicts,\n        errors,\n        performance: { duration, throughput }\n      }\n\n    } catch (error) {\n      logger.error('Sync failed', { userId, error })\n      errors.push(error instanceof Error ? error.message : 'Unknown sync error')\n      \n      return {\n        success: false,\n        operations: results,\n        conflicts,\n        errors,\n        performance: { duration: Date.now() - startTime, throughput: 0 }\n      }\n    } finally {\n      queue.syncInProgress = false\n    }\n  }\n\n  /**\n   * Process a batch of sync operations\n   */\n  private async processBatch(operations: SyncOperation[]): Promise<{\n    successful: number\n    failed: number\n    conflicts: number\n    conflictResolutions: ConflictResolution[]\n    errors: string[]\n  }> {\n    const results = { successful: 0, failed: 0, conflicts: 0 }\n    const conflictResolutions: ConflictResolution[] = []\n    const errors: string[] = []\n\n    await Promise.allSettled(\n      operations.map(async (operation) => {\n        try {\n          const result = await this.processOperation(operation)\n          \n          if (result.success) {\n            results.successful++\n            operation.status = 'completed'\n          } else if (result.conflict) {\n            results.conflicts++\n            operation.status = 'conflict'\n            operation.conflictData = result.conflict\n            \n            // Attempt automatic resolution\n            const resolution = await this.resolveConflict(operation, result.conflict)\n            if (resolution) {\n              conflictResolutions.push(resolution)\n            }\n          } else {\n            results.failed++\n            operation.status = 'failed'\n            operation.retries++\n            errors.push(result.error || 'Unknown operation error')\n          }\n\n          // Update operation status\n          await this.updateSyncOperationStatus(operation)\n\n        } catch (error) {\n          results.failed++\n          operation.status = 'failed'\n          operation.retries++\n          errors.push(error instanceof Error ? error.message : 'Unknown error')\n          await this.updateSyncOperationStatus(operation)\n        }\n      })\n    )\n\n    return { ...results, conflictResolutions, errors }\n  }\n\n  /**\n   * Process a single sync operation\n   */\n  private async processOperation(operation: SyncOperation): Promise<{\n    success: boolean\n    conflict?: any\n    error?: string\n  }> {\n    try {\n      switch (operation.operation) {\n        case 'create':\n          return await this.processCreate(operation)\n        case 'update':\n          return await this.processUpdate(operation)\n        case 'delete':\n          return await this.processDelete(operation)\n        default:\n          return { success: false, error: `Unknown operation: ${operation.operation}` }\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown processing error'\n      }\n    }\n  }\n\n  /**\n   * Process create operation\n   */\n  private async processCreate(operation: SyncOperation): Promise<{\n    success: boolean\n    conflict?: any\n    error?: string\n  }> {\n    try {\n      // Check if record already exists\n      const { data: existing } = await supabase\n        .from(operation.table)\n        .select('id, version, updated_at')\n        .eq('id', operation.localId)\n        .single()\n\n      if (existing) {\n        // Record exists - this is a conflict\n        return {\n          success: false,\n          conflict: {\n            type: 'create_conflict',\n            serverData: existing,\n            clientData: operation.data\n          }\n        }\n      }\n\n      // Insert new record\n      const { data, error } = await supabase\n        .from(operation.table)\n        .insert({\n          ...operation.data,\n          id: operation.localId,\n          created_at: new Date(),\n          updated_at: new Date(),\n          version: 1,\n          sync_status: 'synced'\n        })\n        .select()\n        .single()\n\n      if (error) {\n        return { success: false, error: error.message }\n      }\n\n      operation.serverId = data.id\n      return { success: true }\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Create operation failed'\n      }\n    }\n  }\n\n  /**\n   * Process update operation\n   */\n  private async processUpdate(operation: SyncOperation): Promise<{\n    success: boolean\n    conflict?: any\n    error?: string\n  }> {\n    try {\n      // Get current server version\n      const { data: current } = await supabase\n        .from(operation.table)\n        .select('*')\n        .eq('id', operation.localId)\n        .single()\n\n      if (!current) {\n        return { success: false, error: 'Record not found on server' }\n      }\n\n      // Check for conflicts\n      const clientVersion = operation.data.version || 1\n      if (current.version > clientVersion) {\n        return {\n          success: false,\n          conflict: {\n            type: 'update_conflict',\n            serverData: current,\n            clientData: operation.data,\n            serverVersion: current.version,\n            clientVersion: clientVersion\n          }\n        }\n      }\n\n      // Update record\n      const { data, error } = await supabase\n        .from(operation.table)\n        .update({\n          ...operation.data,\n          updated_at: new Date(),\n          version: current.version + 1,\n          sync_status: 'synced'\n        })\n        .eq('id', operation.localId)\n        .eq('version', current.version) // Optimistic locking\n        .select()\n        .single()\n\n      if (error) {\n        if (error.code === '23505') { // Unique violation - version conflict\n          return {\n            success: false,\n            conflict: {\n              type: 'version_conflict',\n              error: error.message\n            }\n          }\n        }\n        return { success: false, error: error.message }\n      }\n\n      return { success: true }\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Update operation failed'\n      }\n    }\n  }\n\n  /**\n   * Process delete operation\n   */\n  private async processDelete(operation: SyncOperation): Promise<{\n    success: boolean\n    conflict?: any\n    error?: string\n  }> {\n    try {\n      // Check if record still exists and get version\n      const { data: current } = await supabase\n        .from(operation.table)\n        .select('version, updated_at')\n        .eq('id', operation.localId)\n        .single()\n\n      if (!current) {\n        // Already deleted - consider successful\n        return { success: true }\n      }\n\n      // Check for conflicts (record was modified after delete was queued)\n      const deleteTimestamp = operation.timestamp\n      if (new Date(current.updated_at) > deleteTimestamp) {\n        return {\n          success: false,\n          conflict: {\n            type: 'delete_conflict',\n            serverData: current,\n            deleteTimestamp: deleteTimestamp\n          }\n        }\n      }\n\n      // Soft delete (update deleted_at field) or hard delete based on table\n      const isPhiTable = ['messages', 'mood_entries', 'conversation_sessions'].includes(operation.table)\n      \n      if (isPhiTable) {\n        // Soft delete for PHI data (audit requirement)\n        const { error } = await supabase\n          .from(operation.table)\n          .update({\n            deleted_at: new Date(),\n            sync_status: 'deleted'\n          })\n          .eq('id', operation.localId)\n      } else {\n        // Hard delete for non-PHI data\n        const { error } = await supabase\n          .from(operation.table)\n          .delete()\n          .eq('id', operation.localId)\n      }\n\n      return { success: true }\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Delete operation failed'\n      }\n    }\n  }\n\n  /**\n   * Resolve conflicts automatically where possible\n   */\n  private async resolveConflict(\n    operation: SyncOperation,\n    conflictData: any\n  ): Promise<ConflictResolution | null> {\n    try {\n      const strategy = this.selectConflictStrategy(operation, conflictData)\n      \n      switch (strategy) {\n        case 'client_wins':\n          return await this.resolveClientWins(operation, conflictData)\n        case 'server_wins':\n          return await this.resolveServerWins(operation, conflictData)\n        case 'merge':\n          return await this.resolveMerge(operation, conflictData)\n        default:\n          // Manual review required\n          await this.queueManualReview(operation, conflictData)\n          return null\n      }\n    } catch (error) {\n      logger.error('Conflict resolution failed', { operationId: operation.id, error })\n      return null\n    }\n  }\n\n  /**\n   * Select appropriate conflict resolution strategy\n   */\n  private selectConflictStrategy(\n    operation: SyncOperation,\n    conflictData: any\n  ): 'client_wins' | 'server_wins' | 'merge' | 'manual_review' {\n    // For PHI data, prefer client wins (user's latest input)\n    if (['messages', 'mood_entries'].includes(operation.table)) {\n      return 'client_wins'\n    }\n\n    // For configuration data, prefer server wins (latest authoritative)\n    if (['user_preferences', 'settings'].includes(operation.table)) {\n      return 'server_wins'\n    }\n\n    // For metadata, attempt merge\n    if (conflictData.type === 'update_conflict') {\n      return 'merge'\n    }\n\n    // Default to manual review\n    return 'manual_review'\n  }\n\n  /**\n   * Get sync status for a user\n   */\n  async getUserSyncStatus(userId: string): Promise<{\n    isOnline: boolean\n    pendingOperations: number\n    lastSyncAt?: Date\n    syncInProgress: boolean\n    conflicts: number\n  }> {\n    const queue = this.syncQueues.get(userId)\n    \n    if (!queue) {\n      return {\n        isOnline: false,\n        pendingOperations: 0,\n        syncInProgress: false,\n        conflicts: 0\n      }\n    }\n\n    const pendingCount = queue.operations.filter(\n      op => op.status === 'pending' || op.status === 'failed'\n    ).length\n    \n    const conflictCount = queue.operations.filter(\n      op => op.status === 'conflict'\n    ).length\n\n    return {\n      isOnline: true, // TODO: Implement actual network status check\n      pendingOperations: pendingCount,\n      lastSyncAt: queue.lastSyncAt,\n      syncInProgress: queue.syncInProgress,\n      conflicts: conflictCount\n    }\n  }\n\n  /**\n   * Force sync for high priority operations\n   */\n  async forceSyncHighPriority(userId: string): Promise<SyncResult> {\n    const queue = this.syncQueues.get(userId)\n    if (!queue) {\n      throw new Error(`No sync queue found for user ${userId}`)\n    }\n\n    // Filter high priority operations\n    const highPriorityOps = queue.operations.filter(\n      op => op.priority <= 2 && (op.status === 'pending' || op.status === 'failed')\n    )\n\n    if (highPriorityOps.length === 0) {\n      return {\n        success: true,\n        operations: { total: 0, successful: 0, failed: 0, conflicts: 0 },\n        conflicts: [],\n        errors: [],\n        performance: { duration: 0, throughput: 0 }\n      }\n    }\n\n    // Process high priority operations immediately\n    return await this.processBatch(highPriorityOps).then(result => ({\n      success: result.failed === 0,\n      operations: {\n        total: highPriorityOps.length,\n        successful: result.successful,\n        failed: result.failed,\n        conflicts: result.conflicts\n      },\n      conflicts: result.conflictResolutions,\n      errors: result.errors,\n      performance: { duration: 0, throughput: 0 }\n    }))\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async loadPendingOperations(userId: string): Promise<void> {\n    try {\n      const { data: operations } = await supabase\n        .from('sync_operations')\n        .select('*')\n        .eq('user_id', userId)\n        .in('status', ['pending', 'failed'])\n        .order('priority', { ascending: true })\n        .order('timestamp', { ascending: true })\n\n      const queue = this.syncQueues.get(userId)\n      if (queue && operations) {\n        queue.operations = operations.map(op => ({\n          id: op.id,\n          userId: op.user_id,\n          operation: op.operation,\n          table: op.table,\n          localId: op.local_id,\n          serverId: op.server_id,\n          data: op.data,\n          timestamp: new Date(op.timestamp),\n          retries: op.retries,\n          status: op.status,\n          conflictData: op.conflict_data,\n          priority: op.priority\n        }))\n      }\n    } catch (error) {\n      logger.error('Failed to load pending operations', { userId, error })\n    }\n  }\n\n  private async persistSyncOperation(operation: SyncOperation): Promise<void> {\n    await supabase\n      .from('sync_operations')\n      .insert({\n        id: operation.id,\n        user_id: operation.userId,\n        operation: operation.operation,\n        table: operation.table,\n        local_id: operation.localId,\n        server_id: operation.serverId,\n        data: operation.data,\n        timestamp: operation.timestamp,\n        retries: operation.retries,\n        status: operation.status,\n        conflict_data: operation.conflictData,\n        priority: operation.priority\n      })\n  }\n\n  private async updateSyncOperationStatus(operation: SyncOperation): Promise<void> {\n    await supabase\n      .from('sync_operations')\n      .update({\n        status: operation.status,\n        retries: operation.retries,\n        conflict_data: operation.conflictData,\n        updated_at: new Date()\n      })\n      .eq('id', operation.id)\n  }\n\n  private startPeriodicSync(userId: string): void {\n    // Clear existing interval\n    const existingInterval = this.syncIntervals.get(userId)\n    if (existingInterval) {\n      clearInterval(existingInterval)\n    }\n\n    // Start new interval\n    const interval = setInterval(async () => {\n      try {\n        await this.syncUser(userId)\n      } catch (error) {\n        logger.error('Periodic sync failed', { userId, error })\n      }\n    }, this.syncIntervalMs)\n\n    this.syncIntervals.set(userId, interval)\n  }\n\n  private async resolveClientWins(\n    operation: SyncOperation,\n    conflictData: any\n  ): Promise<ConflictResolution> {\n    // Force client data to server\n    await supabase\n      .from(operation.table)\n      .upsert({\n        ...operation.data,\n        id: operation.localId,\n        updated_at: new Date()\n      })\n\n    return {\n      strategy: 'client_wins',\n      resolvedData: operation.data,\n      metadata: {\n        conflictType: conflictData.type,\n        clientVersion: operation.data.version || 1,\n        serverVersion: conflictData.serverVersion || 1,\n        resolvedAt: new Date()\n      }\n    }\n  }\n\n  private async resolveServerWins(\n    operation: SyncOperation,\n    conflictData: any\n  ): Promise<ConflictResolution> {\n    // Accept server data as authoritative\n    return {\n      strategy: 'server_wins',\n      resolvedData: conflictData.serverData,\n      metadata: {\n        conflictType: conflictData.type,\n        clientVersion: operation.data.version || 1,\n        serverVersion: conflictData.serverVersion || 1,\n        resolvedAt: new Date()\n      }\n    }\n  }\n\n  private async resolveMerge(\n    operation: SyncOperation,\n    conflictData: any\n  ): Promise<ConflictResolution> {\n    // Simple merge strategy - combine non-conflicting fields\n    const mergedData = {\n      ...conflictData.serverData,\n      ...operation.data,\n      updated_at: new Date(),\n      version: (conflictData.serverVersion || 1) + 1\n    }\n\n    // Update server with merged data\n    await supabase\n      .from(operation.table)\n      .update(mergedData)\n      .eq('id', operation.localId)\n\n    return {\n      strategy: 'merge',\n      resolvedData: mergedData,\n      metadata: {\n        conflictType: conflictData.type,\n        clientVersion: operation.data.version || 1,\n        serverVersion: conflictData.serverVersion || 1,\n        resolvedAt: new Date()\n      }\n    }\n  }\n\n  private async queueManualReview(\n    operation: SyncOperation,\n    conflictData: any\n  ): Promise<void> {\n    // Store conflict for manual resolution\n    await supabase\n      .from('sync_conflicts')\n      .insert({\n        id: uuidv4(),\n        operation_id: operation.id,\n        user_id: operation.userId,\n        table: operation.table,\n        local_data: operation.data,\n        server_data: conflictData.serverData,\n        conflict_type: conflictData.type,\n        status: 'pending_review',\n        created_at: new Date()\n      })\n  }\n\n  /**\n   * Cleanup resources\n   */\n  cleanup(): void {\n    for (const [userId, interval] of this.syncIntervals) {\n      clearInterval(interval)\n    }\n    this.syncIntervals.clear()\n    this.syncQueues.clear()\n  }\n}\n\nexport const offlineSyncService = new OfflineSyncService()\nexport default offlineSyncService